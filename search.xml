<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA均匀生成随机数</title>
    <url>/JAVA%E5%9D%87%E5%8C%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><p>假如有一个函数rand2()会均匀生成[1,2]的随机数，现在想要实现一个rand4()的函数，第一次接触该类问题时，第一反应是如下所示：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TAP"><figure class="iseeu highlight /tap"><table><tr><td class="code"><pre><span class="line">rand2() + rand2() = ? ==&gt; [2,4]</span><br><span class="line">  <span class="number"> 1 </span>   +  <span class="number"> 1 </span>    = 2</span><br><span class="line">  <span class="number"> 1 </span>   +  <span class="number"> 2 </span>    = 3</span><br><span class="line">  <span class="number"> 2 </span>   +  <span class="number"> 1 </span>    = 3</span><br><span class="line">  <span class="number"> 2 </span>   +  <span class="number"> 2 </span>    = 4</span><br><span class="line"></span><br><span class="line">// 为了把生成随机数的范围规约成[1,n]，于是在上一步的结果后减1</span><br><span class="line">(rand2()-1) + rand2() = ? ==&gt; [1,3]</span><br><span class="line">  <span class="number"> 0 </span>      +  <span class="number"> 1 </span>    = 1</span><br><span class="line">  <span class="number"> 0 </span>      +  <span class="number"> 2 </span>    = 2</span><br><span class="line">  <span class="number"> 1 </span>      +  <span class="number"> 1 </span>    = 2</span><br><span class="line">  <span class="number"> 1 </span>      +  <span class="number"> 2 </span>    = 3</span><br></pre></td></tr></table></figure></div>

<span id="more"></span>

<p>会发现生成的数字不是等概率的，造成这种情况的原因也很明显，有些数字是可以通过几个组合得来，有的只能通过一种组合得来</p>
<p>若我们把(rand2()-1)乘以2，则会得到</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TAP"><figure class="iseeu highlight /tap"><table><tr><td class="code"><pre><span class="line">(rand2()-1) ×<span class="number"> 2 </span>+ rand2() = ?</span><br><span class="line">  <span class="number"> 0 </span>           +  <span class="number"> 1 </span>    = 1</span><br><span class="line">  <span class="number"> 0 </span>           +  <span class="number"> 2 </span>    = 2</span><br><span class="line">  <span class="number"> 2 </span>           +  <span class="number"> 1 </span>    = 3</span><br><span class="line">  <span class="number"> 2 </span>           +  <span class="number"> 2 </span>    = 4</span><br></pre></td></tr></table></figure></div>

<p>得到的结果恰好是等概率的。我们可以通过这种方法实现rand2()-&gt;rand4()</p>
<p>我们再举个例子：有两个均匀随机函数rand9()和rand7()，a=(rand9-1)*7，b = rand7，result = a+b</p>
<p>则能得到下列表格的结果：</p>
<table>
<thead>
<tr>
<th>a\b</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
</tr>
<tr>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
</tr>
<tr>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
</tr>
<tr>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
<td>32</td>
<td>33</td>
<td>34</td>
<td>35</td>
</tr>
<tr>
<td>35</td>
<td>36</td>
<td>37</td>
<td>38</td>
<td>39</td>
<td>40</td>
<td>41</td>
<td>42</td>
</tr>
<tr>
<td>42</td>
<td>43</td>
<td>44</td>
<td>45</td>
<td>46</td>
<td>47</td>
<td>48</td>
<td>49</td>
</tr>
<tr>
<td>49</td>
<td>50</td>
<td>51</td>
<td>52</td>
<td>53</td>
<td>54</td>
<td>55</td>
<td>56</td>
</tr>
<tr>
<td>56</td>
<td>57</td>
<td>58</td>
<td>59</td>
<td>60</td>
<td>61</td>
<td>62</td>
<td>63</td>
</tr>
</tbody></table>
<p>可以看到这样也可以均匀随机的生成[1,63]的随机数，则可以得到这样的一个规律：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="code"><pre><span class="line">已知 rand<span class="constructor">_N()</span> 可以等概率的生成<span class="literal">[<span class="number">1</span>, N]</span>范围的随机数</span><br><span class="line">那么：</span><br><span class="line">(rand<span class="constructor">_X()</span> - <span class="number">1</span>) × Y + rand<span class="constructor">_Y()</span> ==&gt; 可以等概率的生成<span class="literal">[<span class="number">1</span>, X <span class="operator">*</span> Y]</span>范围的随机数</span><br><span class="line">即实现了 rand_X*<span class="constructor">Y()</span></span><br></pre></td></tr></table></figure></div>

<p>公式：<br>$$<br>(rand_X() - 1) × Y + rand_Y() \Rightarrow 可以等概率的生成[1, X * Y]范围的随机数<br>$$</p>
<h2 id="LC题目-优化"><a href="#LC题目-优化" class="headerlink" title="LC题目+优化"></a>LC题目+优化</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>再来看看Leetcode上的这一题：<a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a></p>
<p>要实现rand10()，就需要先实现<code>rand_N()</code>，并且保证N大于10且是10的倍数。这样再通过<code>rand_N() % 10 + 1</code> 就可以得到[1,10]范围的随机数了。</p>
<p>rand_N()的实现方法可以通过上面推导出来的规律得到：</p>
<p><code>(rand7()-1) × 7 + rand7()  ==&gt; rand49()</code></p>
<p>但是这样实现的N不是10的倍数，这该怎么处理？这里就涉及到了“<strong>拒绝采样</strong>”的知识了，也就是说，如果某个采样结果不在要求的范围内，则丢弃它。基于上面的这些分析，再回头看下面的代码，想必是不难理解了。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">SolBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7(); <span class="comment">// 等概率生成[1,49]范围的随机数</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">40</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>; <span class="comment">// 拒绝采样，并返回[1,10]范围的随机数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>根据上面的分析，我们已经知道<code>(rand7() - 1) * 7 + rand7()</code> 等概率生成<code>[1,49]</code>范围的随机数。而由于我们需要的是10的倍数，因此，需要舍弃掉<code>[41, 49]</code>这9个数。优化的点就始于——我们能否利用这些范围外的数字，以减少丢弃的值，提高命中率总而提高随机数生成效率。</p>
<p>当生成的随机数x在<code>[41,49]</code>时，我们拒绝采样这一部分，而舍弃的这一部分我们可以得到<code>[1,9]</code>的均匀随机数，我们将这一随机数通过上面的处理后就可以得到<code>[1,63]</code>的随机数，若这次生成的随机数在<code>[61,63]</code>时，我们也拒绝采样这一部分，而舍弃的这一部分我们可以得到<code>[1,3]</code>的均匀随机数，我们将这一随机数通过上面的处理后就可以得到<code>[1,21]</code>的随机数，若这次生成的随机数为21，则我们拒绝采样21，但是舍弃的21只能得到1这一个随机数，没有用处，所以我们只能重新生成<code>[1,49]</code>的随机数。代码如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">SolBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = (rand7()-<span class="number">1</span>)*<span class="number">7</span>;</span><br><span class="line">            <span class="keyword">int</span> b = rand7();</span><br><span class="line">            <span class="keyword">int</span> num = a+b;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=<span class="number">40</span>)<span class="keyword">return</span> num%<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">            a = (num-<span class="number">40</span>-<span class="number">1</span>)*<span class="number">7</span>;</span><br><span class="line">            b = rand7();</span><br><span class="line">            num = a+b;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=<span class="number">60</span>)<span class="keyword">return</span> num%<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">            a = (num-<span class="number">60</span>-<span class="number">1</span>)*<span class="number">7</span>;</span><br><span class="line">            b = rand7();</span><br><span class="line">            num = a+b;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=<span class="number">20</span>)<span class="keyword">return</span> num%<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行效率也比上面快了许多</p>
<p><img data-src="/JAVA%E5%9D%87%E5%8C%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/image-20210905123421344.png" alt="image-20210905123421344"></p>
<p>保留的数字范围可以通过下面这个公式得到：</p>
<p>假设有<code>rand_X</code>，想得到<code>rand_Y</code>，<br><code>a = (rand_X()-1)*Y</code>，<code>b = rand_X()</code>;<br>则保留范围为：<br>$$<br>[1,Y*((a+b)_{max}/Y)]<br>$$<br>返回的数字为：<br>$$<br>(a+b)\pmod Y + 1<br>$$<br>参考题解链接：<a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/">从最基础的讲起如何做到均匀的生成随机数</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql慢查询——查询优化</title>
    <url>/Mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E2%80%94%E2%80%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>在一些公司的面试题中，可以经常看到有这么一道MySQL的面试题：<code>对于SQL查询慢的问题你要怎么去发现和解决</code>。最初我也大概只能回答个索引相关的，比如”通过EXPLAIN查看查询的访问类型和一些查询情况”， “查看是否可以在某些表的字段增加索引然后改写查询语句”等，网上的八股也很少提及这个问题，所以我还是去阅读了一下《高性能MySQL》，通过阅读后，我也大致地了解了查询的一些问题所在以及优化的方法，这篇文章便是我针对这本书第六章内容的一些整理总结(其实就是相当于摘抄吧 :triumph: )。方便自己记忆的同时也放到博客上来给博客更新一下(其实是都放到本地没怎么上传到博客，属于是懒:dog:了)</p>
<span id="more"></span>

<h2 id="为什么查询慢"><a href="#为什么查询慢" class="headerlink" title="为什么查询慢"></a>为什么查询慢</h2><p>​    在我们看待这个问题的时候，我们就要想：是什么造成SQL的查询慢呢，通过对索引的学习我们也知道索引对于高性能的重要性，但光有索引也是不够的，查询语句的合理性也是要考虑的，如果一个查询语句写的很烂，即使我们的表结构和索引设计的再好，那也是无济于事的。</p>
<p>​    查询的生命周期大致可以这么来看：客户端发送请求到服务器:point_right:服务器进行解析:point_right:生成执行计划:point_right:<strong>执行</strong>:point_right:返回结果给客户端。一个查询会在一个生命周期内涉及到这些个任务，而每个任务的完成时间也是不同的。我们可以针对这么一个大概的生命周期概念，来对我们的查询进行一个优化。</p>
<h2 id="优化查询访问"><a href="#优化查询访问" class="headerlink" title="优化查询访问"></a>优化查询访问</h2><p>​    查询性能低一个最基本的原因是我们访问的数据太多，针对查询数据多这一问题，我们可以看看是否有存在这么两个问题：<code>是否查询了很多我们不需要的数据</code>；<code>MySQL的服务器是否在分析大量超过我们需要的数据</code>。</p>
<h3 id="是否查询了很多不需要的数据"><a href="#是否查询了很多不需要的数据" class="headerlink" title="是否查询了很多不需要的数据"></a>是否查询了很多不需要的数据</h3><p>​    我们通常会认为MySQL返回的是我们需要的数据，但实际上MySQL是<strong>先返回全部的结果集再进行计算</strong>，所以我们有时候要考虑我们是否真的需要这么多数据呢，就好像我们要让一个页面显示10条数据，我们就要先查个100条数据然后再选前10条展示吗，显而易见是不用的，我们加个 limit 即可。</p>
<p>​    对于<code>select *</code>的写法我们也要在使用的时候去想我们是否真的需要去使用它呢，对于一些开发者来说，在知道其性能影响的情况下，这样的写法可以简易开发和做到代码复用，是值得考虑的。<code>select *</code>会使得优化器无法完成<strong>索引覆盖扫描</strong>这类的优化，也会给服务器带来额外的IO、内存和CPU的消耗，在不需要<code>select *</code>的时候它便会给我们造成本没有的性能影响了。</p>
<p>​    也有这么一种容易发生的情况，就是我们多次重复执行了相同的执行并且返回相同的数据，对于这样的数据，我们可以在第一次查询该数据时将其缓存起来，这样后面再需要时直接从缓存中获取即可。</p>
<h3 id="MySQL是否分析扫描额外的数据"><a href="#MySQL是否分析扫描额外的数据" class="headerlink" title="MySQL是否分析扫描额外的数据"></a>MySQL是否分析扫描额外的数据</h3><p>​    当我们确认我们查询返回的确实是我们需要的数据后，我们就应该看看查询为了返回结果是否扫描了过多的数据。通常简单的衡量查询开销的指标是：<code>响应时间</code>,<code>扫描行数</code>,<code>返回行数</code>，这三个指标都记录在了MySQL的<strong>慢日志</strong>中，所以<strong>检查慢日志记录是扫描行数过多的查询的好办法</strong>。</p>
<p>​    如果我们的查询扫描了大量的数据却只返回很少的行，可以考虑如下的优化方式：</p>
<ul>
<li>使用<strong>索引覆盖扫描</strong>，使存储引擎不需要回表即可返回结果</li>
<li>改变库表结构</li>
<li>重写这个复杂查询</li>
</ul>
<h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><p>​    如果我们的查询的列确实是需要的，索引的设计和库表的设计也没什么问题的时候，那么就可以考虑下更改我们的查询方式。对于一个大查询，我们可以考虑对它进行<code>分而治之</code>的方法来进行多个小查询。对于一些关联查询，我们也考虑是不是能对它进行<strong>分解</strong>，就像书上的例子那样：</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220817170821072.png" alt="image-20220817170821072"></p>
<p>​    这样可以让缓存的效率更高，因为有缓存，我们可能可以跳过某条查询或者减少IN()里的内容。也可以减少了锁的竞争。这样的查询也可能能提升查询效率，<code>IN()</code>让MySQL按照ID顺序进行查询，顺序IO是要比随机IO高效的。这样还可以减少冗余记录的查询，在数据库上关联查询我们就可能需要重复访问同一数据，在应用层上进行关联让我们可以对某条数据只查询一次，减少了网络和内存的消耗。</p>
<p>上面所讲的是针对查询的访问和方式，但如果知道MySQL如何优化和执行查询时，那我们在优化查询时便可以按照一些原则让优化器能按我们设想的方向运行。下面这张图是发送一个请求时MySQL所做的事情：</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220817172702465.png" alt="image-20220817172702465"></p>
<p>图中的<code>查询缓存</code>在MySQL8已经是关闭的了，《高性能MySQL》所基于的版本还是5版本的，所以如果是8版本或以上的是可以忽略掉查询缓存的。书上在<code>查询优化</code>做了很多的篇幅进行讲解，讲了很多优化器在一些查询上的优化细节和做法，这部分如果放上来记录的话篇幅还是挺长的，多到我也不知道怎么整理写上了比较好，所以第六章的查询优化处理这块还是很建议大家去阅读原书的，在这里我就先不写着了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    一个高性能的查询，需要好的库表设计、索引设计、查询语句设计和查询的优化方式，而查询的优化设计又是很多细节的，所以当SQL查询慢的原因是由于我们查询语句设计不妥当时，便可以照着该书籍第六章的方法去进行优化。</p>
<p>​    通过网上资料的搜索SQL查询慢的原因也可能不在于查询语句的问题，比如网络不好的情况下，客户端和服务端之间的连接和传输受到影响、IO吞吐量小、缓存不够、出现死锁等等，硬件软件都会或多或少的影响到查询，还是要针对特定的原因去寻找对应的解决办法的。对于我个人来说，排插SQL查询慢的基本方向是通过查询<strong>慢日志</strong>来定位慢查询SQL，然后通过<strong>explain</strong>命令去分析该SQL的执行计划后进行相应的优化，如果优化完还是查询慢或者没有什么优化方向后，就再去考虑网络、内存、服务器和应用程序设计上的问题。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>在文章中添加图片</title>
    <url>/TestPage/</url>
    <content><![CDATA[<p>这是通过 <code>hexo new TestPage</code> 命令所创建的一篇文章，存放在source目录下的_posts.</p>
<p>贴张图片测试一下能不能成功显示出来：👇</p>
<p><img data-src="/TestPage/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201108102123.jpg" alt="测试图片"></p>
<span id="more"></span>

<p>若图片显示不出来，则在<code>站点根目录</code>下安装插件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></div>

<p>修改<code>站点配置文件</code></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">post_asset_folder: <span class="literal">true</span></span><br><span class="line">marked:</span><br><span class="line">  prependRoot: <span class="literal">true</span></span><br><span class="line">  postAsset: <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>

<p>这样在创建文章时，会同样生成一个同名文件夹</p>
<p><img data-src="/TestPage/image-20210507150008908.png" alt="实例"></p>
<p>由于hexo生成的是.md文件，所以下载Typora进行文本编辑是一个很好的选择。从typora左上角的文件-&gt;偏好设置-&gt;图像里，在<code>插入图片时</code>那里改成复制到指定路径，并勾选上前三项</p>
<p><img data-src="/TestPage/image-20210507150259312.png" alt="image-20210507150259312"></p>
<p><del>当把图片复制到xxx文章后，图片会自动变为  ![](xxx/图片名.图片类型)，最后把xxx/去掉即可。</del></p>
<p>(第一次测试时去掉xxx/是可行的，后面又不行，因此重新加回xxx/)</p>
]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>在文章中添加更新时间</title>
    <url>/makeUpdTime/</url>
    <content><![CDATA[<p>鉴于网上的文章许多都是通过修改<code>/themes/next/layout/_macro/post.swig</code>，并在<code>&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;</code>标签后添加一段代码，但是现在的版本找不到swig文件。所以写下这篇文章记录下该方法。</p>
<span id="more"></span>

<h2 id="初始方法-不需要"><a href="#初始方法-不需要" class="headerlink" title="初始方法(不需要)"></a>初始方法(不需要)</h2><p><del>经过几番查找和试验，可以<code>themes\next\layout\_partials\post\post-meta.njk</code>进行修改，并在如图所示的地方加入该代码：</del></p>
<p><img data-src="/makeUpdTime/image-20210508000023413.png" alt="添加位置"></p>
<p><del>代码如下：</del></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HTML"><figure class="iseeu highlight /html"><table><tr><td class="code"><pre><span class="line">&#123;%if post.updated and post.updated &gt; post.date%&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-updated&quot;</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span> &#123;&#123; __(&#x27;post.updated&#x27;) &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">time</span> <span class="attr">itemprop</span>=<span class="string">&quot;dateUpdated&quot;</span> <span class="attr">datetime</span>=<span class="string">&quot;&#123;&#123; moment(post.updated).format() &#125;&#125;&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&#123;&#123; date(post.updated, config.date_format) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; date(post.updated, config.date_format) &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></div>

<p>在你所对应的<code>language</code>配置文件(我的是zh-CN，目录为themes/next/languages/zh-CN.yml)添加或修改如下字段</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post:</span></span><br><span class="line">  <span class="attr">updated:</span> <span class="string">更新于</span></span><br></pre></td></tr></table></figure></div>

<p>在<code>主题配置文件</code>(/themes/next/_config.yml)中加入如下一行代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">display_updated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>



<p>这样更新时间就能显示出来了。</p>
<p><img data-src="/makeUpdTime/image-20210508001321657.png" alt="image-20210508001321657"></p>
<hr>
<h2 id="现方法"><a href="#现方法" class="headerlink" title="现方法"></a>现方法</h2><p>后面的测试莫名其妙地发现不用加上面那一大段代码。</p>
<p>在<code>主题配置文件</code>(/themes/next/_config.yml)中加入如下一行代码和修改post_meta的update_at</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以加在最后一行</span></span><br><span class="line"><span class="attr">display_updated:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改update_at</span></span><br><span class="line"><span class="attr">post_meta:</span></span><br><span class="line"> <span class="attr">updated_at:</span></span><br><span class="line">     <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">     <span class="attr">another_day:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>

<p>在你所对应的<code>language</code>配置文件(我的是zh-CN，目录为themes/next/languages/zh-CN.yml)添加或修改如下字段</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post:</span></span><br><span class="line">  <span class="attr">updated:</span> <span class="string">更新于</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>代码块Mac风格</title>
    <url>/%E4%BB%A3%E7%A0%81%E5%9D%97Mac%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<p>看到网上别人博客的代码块都是Mac风格＋黑底，于是乎我也整一波，但是发现按照网上的来修改highlight_theme还是不得行，主要是网上的大部分是旧版的，跟现版本的配置文件有点出入，于是在看了一堆博客和分析报错原因后，我找到了实现的办法。</p>
<p><img data-src="/%E4%BB%A3%E7%A0%81%E5%9D%97Mac%E9%A3%8E%E6%A0%BC/image-20210508161438627.png" alt="image-20210508161438627"></p>
<span id="more"></span>

<p>通过 <a href="https://miaosakurai.com/">樱井喵</a> 的这一篇 <a href="https://miaosakurai.com/2020/04/20/Hexo-NexT%E7%BE%8E%E5%8C%96%F0%9F%8D%95Mac-Panel%E9%A3%8E%E6%A0%BC%E4%BB%A3%E7%A0%81%E5%9D%97%E9%85%8D%E7%BD%AE/">博客</a> ，直接在 <code>主题配置文件</code>配置一下 <code>codeblock.copy_button.style: mac</code>就行了</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure></div>

<p>要实现上面代码块的样式，我们可以在<code>站点目录\node_modules\highlight.js\styles</code>里发现有许多中css样式(tomorrow-theme也在其中)</p>
<p><img data-src="/%E4%BB%A3%E7%A0%81%E5%9D%97Mac%E9%A3%8E%E6%A0%BC/image-20210508160824026.png" alt="image-20210508160824026"></p>
<p>我们找到<code>主题配置文件</code>中的theme，把light和dark都改成上述文件夹里的某种样式就行了，我用的是tomorrow-night-bright，也就是本文代码块的样式。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">tomorrow-night-bright</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">tomorrow-night-bright</span></span><br></pre></td></tr></table></figure></div>

<p>不过这种会对小代码块也同样生效，暂时我还没找到方法，等待后面找到了我再进行一波更新。</p>
<p>在报错中我也找到了一个highlight.js的地址：<code>站点目录\themes\next\scripts\events\lib\highlight.js</code></p>
]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>代码块</tag>
      </tags>
  </entry>
  <entry>
    <title>创建分支存储源文件</title>
    <url>/%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF%E5%AD%98%E5%82%A8%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>为了防止日后出现换电脑的情况而导致自己的配置文件和一些文档消失，所以创建一个分支存放源文件是有必要的，当然你也可以选择存放到云盘，只要你记得更新就是了。创建分支存放的方法其实也不是很复杂。</p>
<span id="more"></span>

<h2 id="初始化版本库并与远程仓库关联"><a href="#初始化版本库并与远程仓库关联" class="headerlink" title="初始化版本库并与远程仓库关联"></a>初始化版本库并与远程仓库关联</h2><p>一般按照网上方法所创建的博客是没有与远程仓库建立关联的，通过几个git命令来进行关联。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">//将你的本地文件夹初始化成一个版本库</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">//用 git remote add origin 你的github仓库地址 命令来建立与远程仓库的关联，这里的 origin 是你定义的远程仓库在本地的名字，你也可以叫别的，一般命名成 origin</span><br><span class="line">git remote add origin <span class="string">&quot;你的仓库地址&quot;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="创建并切换分支，提交文件"><a href="#创建并切换分支，提交文件" class="headerlink" title="创建并切换分支，提交文件"></a>创建并切换分支，提交文件</h2><p>创建并切换分支：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git checkout -b <span class="string">&quot;新分支名&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>提交文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m<span class="string">&quot;源文件&quot;</span></span><br><span class="line"></span><br><span class="line">git push origin <span class="string">&quot;新分支名&quot;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="在GitHub中更改新分支为默认分支"><a href="#在GitHub中更改新分支为默认分支" class="headerlink" title="在GitHub中更改新分支为默认分支"></a>在GitHub中更改新分支为默认分支</h2><p>把新建的分支设置成 默认分支，这样做的原因可以让你以后在别的机器上pull的时候能够直接拉取源文件，不用再指定分支。</p>
<p>在GitHub中进入settings中的branches，点击双向箭头进行切换。</p>
<p><img data-src="/%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF%E5%AD%98%E5%82%A8%E6%BA%90%E6%96%87%E4%BB%B6/image-20210508010923455.png" alt="image-20210508010923455"></p>
<p>选中新创分支并点击Update</p>
<p><img data-src="/%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF%E5%AD%98%E5%82%A8%E6%BA%90%E6%96%87%E4%BB%B6/image-20210508011012859.png" alt="image-20210508011012859"></p>
<p>它会弹出一个红色的经过，直接sure就行了。</p>
<h2 id="后续日常管理操作"><a href="#后续日常管理操作" class="headerlink" title="后续日常管理操作"></a>后续日常管理操作</h2><p>只要你的<code>站点配置文件</code>里deploy的branch是master，在你执行<code>hexo g -d</code>后也同样会更新。在你进行了文章添加修改或修改样式等改动后，通过下面流程进行管理：</p>
<ol>
<li>依次执行<code>git add .</code> 、<code>git commit -m&quot;xxx&quot;</code>、<code>git push origin 新创分支名</code>推送到GitHub(注意此时当前分支是你新创的分支)。</li>
<li>执行<code>hexo g -d</code>发布网站到master分支上</li>
</ol>
<p>建议不要调转这两者的顺序</p>
<h2 id="在其他电脑修改博客"><a href="#在其他电脑修改博客" class="headerlink" title="在其他电脑修改博客"></a>在其他电脑修改博客</h2><p>通过git clone将仓库拉下来(默认分支为你当时新创的分支)</p>
<p>然后在你copy下来的仓库文件夹通过git bash执行一下指令：<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>（不需要<code>hexo init</code>）。</p>
]]></content>
      <categories>
        <category>hexo配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈虚拟内存</title>
    <url>/%E6%B5%85%E8%B0%88%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>​    关于虚拟内存，本人虽然在上学校的操作系统课的时候有学到过，但说来惭愧，我对这一块的知识也是没有完全的掌握，还感觉到有点抽象。所以最近两天阅读了下CSAPP的虚拟内存这一章和参考了小林coding有关内存管理的笔记，终于是对虚拟内存这一块有了个大致的理解。</p>
<span id="more"></span>

<h2 id="何为虚拟内存"><a href="#何为虚拟内存" class="headerlink" title="何为虚拟内存"></a>何为虚拟内存</h2><p>​    如果我们所有操作都直接去操作到物理内存的话很容易出现问题，当太多的进程需要太多的内存时，会因为内存的不足而导致部分进程无法运行。而且由于都是操作一块物理内存，很容易有一个进程写了另一个进程使用的内存造成问题，不好管理。所以为了更好地对内存进行管理，就有了虚拟内存。</p>
<p>​    虚拟内存是对主存的一个抽象，我个人的理解来说，虚拟内存是磁盘里某个部分的映射，也就是虚拟内存其实是磁盘里某块连续的空间来的。虚拟内存的好处如下：</p>
<blockquote>
<ul>
<li>把主存当作是一个存储在磁盘上的地址空间的<strong>高速缓存</strong>，虚拟内存维护的是磁盘里面的数据，而这些数据在需要时会从磁盘缓存到主存中，让进程认为自己拥有这么一块主存空间，而主存存储一些活动区域，进程的部分代码可以缓存在其中，大大地<strong>提高了主存的利用率</strong>。</li>
<li>虚拟内存为每个进程都提供了一致的地址空间，每个进程都有自己的私有区域和共享区域，即<strong>方便了内存的管理</strong>，也<strong>保护了每个进程的地址空间不被其他进程破坏</strong>。</li>
</ul>
</blockquote>
<h2 id="虚拟内存结构"><a href="#虚拟内存结构" class="headerlink" title="虚拟内存结构"></a>虚拟内存结构</h2><p>​    CSAPP中有这么一张图描绘了Linux下虚拟内存的结构：</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220821174738227.png" alt="image-20220821174738227"></p>
<p>​    图中可以看到虚拟内存的结构就是一个<code>[内核虚拟内存][进程虚拟内存]</code>。</p>
<h3 id="内核虚拟内存"><a href="#内核虚拟内存" class="headerlink" title="内核虚拟内存"></a>内核虚拟内存</h3><p>​    内核虚拟内存中又有对于每个进程而言相同和不相同的区域。物理内存和内核代码数据结构对每个进程来说是一样的，这部分区域里有着所映射的所有进程共享的物理页面，还有内核的代码和全局数据结构。另外一部分就是每个进程不同的数据部分，例如每个进程自己的页表、描述了进程任务的<code>task_struct</code>结构、描述了进程使用的虚拟内存情况的<code>mm_struct</code>结构和内核在执行上下文中执行代码时使用的栈。</p>
<p>​    <code>task_struct</code>是内核为每一个进程维护的一个单独的任务结构，这个结构的元素包含或者指向内核运行该进程所需要的所有信息，例如<strong>进程ID、指向用户栈的指针、可执行目标文件的名字和程序计数器</strong>等。该结构里有一个元素指向了<code>mm_struct</code>，这个结构描述了虚拟内存当前的状态，该结构里我们关注<code>pgd</code>和<code>mmap</code>这两个字段，<code>pgd</code>指向的是一级页表的基址，而<code>mmap</code>指向的是一个描述区域结构<code>vm_area_structs</code> 的链表，这个区域结构描述了当前虚拟地址空间的一个区域。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220821180629323.png" alt="image-20220821180629323"></p>
<p>​    <code>vm_prot</code>描述了该区域内的页面读写权限，<code>vm_flags</code>描述了该区域内的页面是私有还是共享的。</p>
<h3 id="进程虚拟内存"><a href="#进程虚拟内存" class="headerlink" title="进程虚拟内存"></a>进程虚拟内存</h3><p>​    进程虚拟内存从下到上的顺序是<code>.text</code>→<code>.data</code>→<code>.bss</code>→<code>运行时堆</code>→<code>共享库的内存映射区域</code>→<code>用户栈</code>，剩下的一些区域没有虚拟页，内核不记录这些不存在的虚拟页，这些部分也不占用任何的资源。</p>
<p>​    <code>.text</code>存储的是编译好的代码段。</p>
<p>​    <code>.data</code>存储的是已经进行了初始化的数据。</p>
<p>​    <code>.bss</code>存储的是还未进行初始化的数据或者初始化为0的数据，是请求二进制零的，仅是占位符，不占空间。</p>
<p>​    <strong><code>.text</code>段是只读的</strong>，而**<code>.data</code>和<code>.bss</code>段是可读/写的**。</p>
<p>​    <code>运行时堆</code>则是运行时创建的一个区域，在C/C++中通常是通过<code>malloc</code>进行分配的，堆主要是存储的是我们运行进程时创建的一些变量对象等内容，内核维护着一个<code>brk</code>指针，指向堆的顶部。</p>
<p>​    <code>共享库的映射区域</code>存储的就是与当前进程链接的共享对象的映射，概括的说就是动态库、共享内存等。</p>
<p>​    <code>用户栈</code>则存储的是局部变量和函数调用的上下文等。</p>
<p>​    如果学过Java的JVM的，对堆和栈都或多或少有印象和认识的，学习了虚拟内存后再去回顾JVM中类加载机制、对象创建和<strong>volatile</strong>变量的底层原理，说不定会有更加深刻的认知和记忆。</p>
<h2 id="虚拟页"><a href="#虚拟页" class="headerlink" title="虚拟页"></a>虚拟页</h2><p>​    虚拟内存被系统分割成大小固定的块，这些块我们叫做<strong>虚拟页</strong>，物理内存分割的我们类似地称为<strong>物理页</strong>。虚拟页可以分为下面这三种：</p>
<blockquote>
<ul>
<li>已经被分配且缓存在物理内存中的</li>
<li>已经被分配但是还未缓存在物理内存中的</li>
<li>还未被分配的。</li>
</ul>
</blockquote>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220821223900550.png" alt="image-20220821223900550"></p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>​    为了判定一个虚拟页是否有缓存在物理内存中，使用到了一个叫做<strong>页表</strong>的结构，虚拟地址空间的每个页都有个在页表的页表项，这个页表项存有这个页面的有效位和其对应的物理地址或者磁盘地址，当有效位为1时，为物理地址，有效位为0时，如果页面已经分配，则为磁盘地址，否则为空地址。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220821233804778.png" alt="image-20220821233804778"></p>
<p>​    页面的查找流程通常是这样的：处理器生成一个虚拟地址给CPU里的MMU(内存管理单元)，然后MMU翻译出这个虚拟地址所对应的页表项地址去页表查找，如果对应的页在内存中，则内存向MMU返回对应的页表项，然后MMU得出对应的物理地址后传送到内存中，最后内存返回所请求的数据给处理器。</p>
<h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>​    上面是比较理想的情况，也有出现缺页的情况，即对应的物理页不在内存中，这时候就会触发缺页中断，系统由用户态进入到内核态，调用缺页异常处理程序，这个程序会选择一个牺牲页，如果该页面是个脏页面，内核就会把它写回磁盘后释放掉。然后再从磁盘中将对应的页面复制到内存中并更新页表，重新回到引起缺页的指令。而这在磁盘和内存之间传送页的行为称之为<strong>交换</strong>或者<strong>页面调度</strong>。要注意页面没有命中的影响是挺大的。如果调度的页面大小超过了物理内存的大小，就会不断进行页面地换入换出，造成<strong>抖动</strong>，这是很不好的影响。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220821231454373.png" alt="image-20220821231454373"></p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>​    通常我们的页面的大小为<code>4KB</code>，一个页表项的大小为<code>4B</code>，在32位的系统下，就有$$2^{20}$$个页面，这样一个进程的页表就达到了<code>4MB</code>。所以就有了<strong>多级页表</strong>。假设我们有一个二级页表，第一级页表存储的是指向第二级页表的地址，第二级页表存储的是物理地址或者磁盘地址。这样我们就可以用一个<code>4KB</code>的一级页表去管理理论上总共<code>4MB</code>的二级页表，这看起来好像比之前多了，但其实我们往往不会为一个进程分配那么多内存的，而且如果一级页表的某个页表项是空的，则其对应的二级页表也不会存在的，只有在需要时才会创建，我们假设一级页表只有20%的页面在使用，那么所需要的的内存就是$$4KB+4MB*0.2=0.804MB$$，对比起只有单独的页表的<code>4MB</code>，那是节省了巨大的内存。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220821233204041.png" alt="image-20220821233204041"></p>
<h3 id="快表TLB"><a href="#快表TLB" class="headerlink" title="快表TLB"></a>快表TLB</h3><p>​    除了多级页表，也有一个<code>TLB</code>，即我们所说的<strong>快表</strong>。根据<strong>局部性原理</strong>，在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。我们把程序最常访问的页表项存在快表中，且快表是在CPU芯片里的，地址的翻译步骤都在MMU上，如果命中页面的话那速度是非常快的。如果快表没有命中，就会查找常规的页表，然后把查找到的页表项也存储到快表中，这一步可能会覆盖掉某个快表上的条目。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220821233649707.png" alt="image-20220821233649707"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li><a href="https://xiaolincoding.com/os/3_memory/vmem.html">小林coding-为什么要有虚拟内存</a></li>
<li>《深入理解计算机系统》</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾回收</title>
    <url>/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>​    对于Java，大部分的对象都是分配在堆内存中，但是内存是有限的，不可能无限地去申请内存分配给对象，所以就需要有垃圾回收，来将一些没有被引用，已经不需要的东西释放掉来省出空间来。本文主要大概地总结下Java如何判断一个对象的存活、Java的垃圾收集算法、Java的经典垃圾收集器和一些内存分配策略。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220901225648339.png" alt="image-20220901225648339"></p>
<span id="more"></span>

<h2 id="判断对象存活"><a href="#判断对象存活" class="headerlink" title="判断对象存活"></a>判断对象存活</h2><p>​    通常所比较常见的一种判断对象存活的方法是引用计数法，即通过一个引用计数器记录该对象的引用次数，当其计数为0时即没有人再使用它。但是这种方法也存在一个问题，就是如果有两个对象之间相互引用，那么它们的引用就不会为0，而Java也确实没有采用这种引用计数法，而是采用了<code>可达性分析</code>来作为判断对象存活的方法。</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>​    对于可达性分析的介绍，我引用《深入理解Java虚拟机》里的话：</p>
<blockquote>
<p>​    通过一系列称为“<strong>GC Roots</strong>”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
</blockquote>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220901230313767.png" alt="image-20220901230313767"></p>
<p>​    像图中的obj5、6、7因为到达不了GC Roots，在垃圾回收时它们就会被回收掉。</p>
<p>​    可以作为GC Roots的对象为以下几种：</p>
<ul>
<li>在<strong>虚拟机栈</strong>（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法<strong>堆栈中使用到的参数、局部变量、临时变量</strong>等。</li>
<li>在方法区中<strong>类静态属性引用的对象</strong>，譬如Java类的引用类型静态变量。</li>
<li>在方法区中<strong>常量引用的对象</strong>，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<p>前三种对象我分别举个例子：</p>
<p>虚拟机栈中引用的对象：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    	Root a = <span class="keyword">new</span> Root();<span class="comment">//a是栈帧中的本地变量，a为GC Root</span></span><br><span class="line">        a = <span class="keyword">null</span>;<span class="comment">//此时断开了a与之前new Root()对象的连接，该对象变成不可达会被回收。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>类静态属性引用的对象：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Root b;<span class="comment">//类静态属性b,也为GC Root</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    	Root a = <span class="keyword">new</span> Root();<span class="comment">//a是栈帧中的本地变量，a为GC Root</span></span><br><span class="line">        Root c = <span class="keyword">new</span> Root();</span><br><span class="line">        a.b = c;<span class="comment">//类静态属性指向了c</span></span><br><span class="line">        a = <span class="keyword">null</span>;<span class="comment">//a之前指向的对象会被回收，但是类静态属性b指向的c仍然存活。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>常量引用的对象：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Root b = <span class="keyword">new</span> Root();<span class="comment">//常量b，为GC Root</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    	Root a = <span class="keyword">new</span> Root();<span class="comment">//a是栈帧中的本地变量，a为GC Root</span></span><br><span class="line">        a = <span class="keyword">null</span>;<span class="comment">//a之前指向的对象会被回收，但是常量b指向的对象仍然存活。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><p>​    Java将引用分为了如下四种：</p>
<ul>
<li>强引用：只要强引用关系(类似Object obj = new Object())存在则被引用的对象永远不会被回收</li>
<li>软引用：只被软引用关联着的对象，在系统将要发生<strong>内存溢出</strong>异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用：当垃圾收集器开始工作，<strong>无论当前内存是否足够</strong>，都会回收掉只被弱引用关联的对象。</li>
<li>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能<strong>在这个对象被收集器回收时收到一个系统通知</strong>。</li>
</ul>
<h3 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h3><p>​    方法区的垃圾收集主要回收两部分内容：<strong>废弃的常量</strong>和<strong>不再使用的类型</strong>。</p>
<p>​    废弃常量的判断是比较简单的，对于一个类是否不再被使用，则需要同时满足以下三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>即使同时满足了上面三个条件，虚拟机也只是允许它们可以被回收，没有说一定就要执行回收。</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>​    算法分为“<strong>标记</strong>”和“<strong>清除</strong>”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220901233059325.png" alt="image-20220901233059325"></p>
<p>​    标记-清除算法主要有两个缺点：第一个是执行效率的不稳定，标记和清除的操作是需要花费时间的，如果堆中大量对象需要被回收，就会进行大量的标记和清除动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是容易产生内存碎片，标记清除后会产生大量不连续的内存碎片，如果碎片太多，就可能会导致一个大对象因为得不到一个连续的内存而提前触发另一次垃圾回收。</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>​    针对标记-清除算法的问题，提出了标记-复制算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。通常情况下多数的对象都是可回收的，因此需要复制的存活对象是占少数的，内存复制的开销不会太大。而且分配时也不用考虑碎片的情况，只要移动堆顶指针按顺序分配即可。但该算法的缺陷就是造成了空间浪费，原本能使用的内存空间被砍了一半。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220901234032025.png" alt="image-20220901234032025"></p>
<p>​    针对新生代大部分对象都活不过第一轮收集，像HotSpot的Serial、ParNew等新生代收集器采用了<code>Appel式回收</code>的策略来设计新生代的内存布局，具体做法是把新生代分为<strong>一块较大的Eden空间和两块较小的Survivor空间</strong>，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。Eden和Survivor的大小比例默认是8:1，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>​    针对老年代大部分对象都是存活这种特征，采用标记-复制的话会花费很大的开销，针对老年代的情况，提出了标记-整理算法。其标记过程和标记-清除一样，后续的步骤则是是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220901235435201.png" alt="image-20220901235435201"></p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>​    Java将堆划分成了不同的区域，这样垃圾收集器就可以针对区域来进行回收而不需要去关注整个堆内存。通常的分代将堆分为<strong>新生代</strong>和<strong>老年代</strong>，新生代的对象存活周期大部分是很短的，如果一个对象在新生代存活到一定周期则会晋升到老年代中。上面所提到的三种算法也正是基于分代收集理论发展出来的。对于<strong>新生代</strong>这种存活对象少的，采用的比较多的是<strong>复制算法</strong>。<strong>老年代</strong>这种存活对象多的则采用<strong>清除算法或者整理算法</strong>，使用哪种看具体的垃圾收集器。</p>
<h2 id="HotSpot的一些算法细节"><a href="#HotSpot的一些算法细节" class="headerlink" title="HotSpot的一些算法细节"></a>HotSpot的一些算法细节</h2><p>​    Java采用可达性分析来判断一个对象是否存活，<strong>根节点的枚举</strong>是必要的。而根节点的枚举是<strong>必须暂停用户线程</strong>的，也就是要面临<code>Stop The World</code>，不然如果在枚举的过程中引用关系一直发生变化的话，分析的准确性会造成影响，即使是CMS、G1、ZGC这些停顿时间可控或者几乎不会有停顿的垃圾收集器，在进行根节点枚举时也是要暂停用户线程的。</p>
<p>​    HotSpot使用了OopMap这一数据结构来实现直接得到哪个地方存放着对象引用这一目的，这一就不需要一个个地从方法区等GC Roots开始查找。而HotSpot不会为每条指令生成OopMap，只会在某些特定的位置记录这些信息，这些位置就被称之为<code>安全点</code>，程序执行到安全点后才能暂停。但实际中可能会有线程在没到达安全点之前阻塞或者休眠了，无法到安全点，虚拟机也不可能一直等待线程被激活，所以就有了<code>安全区域</code>。安全区域是指能够确保在<strong>某一段代码片段</strong>之中，<strong>引用关系不会发生变化</strong>，因此，在<strong>这个区域中任意地方</strong>开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
<p>​    前面提到了分代收集理论，分代会存在这么一种情况，就是新生代里的对象被老年代引用，即跨代引用，像G1、ZCG、Shenandpah这些有涉及到部分区域收集行为的收集器也会面临跨代引用，这会使得整个老年代都会加入到GC Roots的扫描范围中，为了避免这种问题，垃圾收集器在新生代中建立了一种叫<code>记忆集</code>的数据结构。<strong>记忆集</strong>是一种用于<strong>记录从非收集区域指向收集区域的指针集合</strong>的抽象数据结构，收集器只需要通过记忆集<strong>判断出某一块非收集区域是否存在有指向了收集区域的指针</strong>就可以了，并不需要了解这些跨代指针的全部细节。记忆集最常见的实现形式是通过<code>卡表</code>去实现。HotSpot对卡表的实现逻辑是一个<strong>字节数组</strong>，其默认的卡表标记逻辑如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>Java将地址右移9位来映射到卡表的索引，也是说明HotSpot中卡页的大小是<strong>512字节</strong>，即$$2^9$$。一个卡页对应着内存区域中一块大小为512字节的内存块，如果该卡页内有一个或多个存在跨代引用指针，则将其标记为脏页，即对应数组位置赋值为1。当发生垃圾收集时，只需要筛选出卡表中的脏元素就能轻易得到哪些区域存在跨代指针，并将这些区域加入到GC Roots中进行扫描。</p>
<p>​    一个卡页变脏原则上是发生在引用类型字段赋值的时候，将其在数组的位置赋值为1。卡表的状态我们要进行维护的，在解释处理器中维护是比较容易的，但是在编译执行的场景中，经过即时编译后的代码已经是纯粹的机器指令流了，这就必须找到一个在机器码层面的手段，把维护卡表的动作放到每一个赋值操作之中，而HotSpot通过<code>写屏障(Write Barrier)</code>来维护卡表的状态，这里的写屏障和volatile字段的写屏障并不是同一个概念。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的<strong>AOP切面</strong>，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。直到G1收集器(G1采用<strong>写前屏障和写后屏障</strong>)出现前，其他收集器采用的都是<strong>写后屏障</strong>。其简化逻辑如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 引用字段赋值操作</span></span><br><span class="line">	*field = new_value;</span><br><span class="line">	<span class="comment">// 写后屏障，在这里完成卡表状态更新</span></span><br><span class="line">	<span class="built_in">post_write_barrier</span>(field, new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，<strong>无论更新的是不是老年代对新生代对象的引用</strong>，每次只要对引用进行更新，就会产生额外的开销，也就是说写屏障是<strong>宁可错失也不放过</strong>。</p>
<p>​    在高并发的场景中，卡表也会面临<code>伪共享</code>的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些<strong>变量恰好共享同一个缓存行</strong>，就会<strong>彼此影响</strong>（<strong>写回、无效化或者同步</strong>）而导致性能降低，这就是伪共享问题。对于一个<strong>64字节大小的缓存行</strong>，由于<strong>卡表元素大小为一个字节</strong>，就会有<strong>64个卡页共享同一个缓存行</strong>，一个卡页的大小为512字节，这样卡页的总内存就达到了<strong>32KB</strong>(64*512字节)的大小。如果不同的线程更新到了这一区域的对象，就会导致更新卡表时写入同一个缓存行而影响性能。为了避免伪共享的问题，采用了有条件的写屏障，即<strong>先检查卡表标记</strong>，只有当该卡表元素未被标记过时才将其标记为变脏，即将卡表更新的逻辑变为以下代码所示：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] != <span class="number">0</span>)</span><br><span class="line">	CARD_TABLE [<span class="keyword">this</span> address &gt;&gt; <span class="number">9</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>JDK 7之后HotSpot增加了一个参数-XX：+UseCondCardMark来决定是否开启卡表更新的条件判断，虽然开启后会增加额外判断的开销，但是可以避免伪共享的问题。</p>
<p>​    在并发场景的可达性分析中，可能会有这么两种情况，一种是把原本消亡的对象错误标记为存活，造成浮动垃圾，这是可以容忍的情况，下次收集时清理掉就行。另一种情况是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误。根节点的枚举和对象图的遍历是要保持在一个能保障一致性的快照上进行的，通过<code>三色标记</code>来推导这些过程。针对对象是否被访问过，我们采用黑、白、灰三种颜色。白色表示<strong>对象未被垃圾收集器访问过</strong>，在可达性分析开始时除了根节点都是白色节点，分析结束后仍为白色的节点则是不可达的；黑色表示<strong>对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过</strong>。黑色的节点是安全存活的，而且黑色节点不可能不经过灰色对象直接指向白色对象；灰色对象表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。正常的标记过程如下图所示：</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220902170736410.png" alt="image-20220902170736410"></p>
<p>但在并发下可能会有下图的情况：</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220902171113675.png" alt="image-20220902171113675"></p>
<p>对象消失的问题当且仅当同时满足以下两个条件时发生：</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ul>
<p>所以要解决对象消失的问题只需要破坏其中一个条件即可。解决方案有两种：<code>增量更新</code>和<code>原始快照</code>。</p>
<p><strong>增量更新</strong>破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就<strong>将这个新插入的引用记录下来</strong>，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，<strong>重新扫描一次</strong>。这可以简化理解为，<strong>黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了</strong>。CMS收集器的并发标记是通过增量更新来进行。</p>
<p><strong>原始快照</strong>破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就<strong>将这个要删除的引用记录下来</strong>，在并发扫描结束之后，再<strong>将这些记录过的引用关系中的灰色对象为根，重新扫描一次</strong>。这也可以简化理解为，<strong>无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索</strong>。G1、Shenandoah收集器采用原始快照来进行并发标记。</p>
<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>​    Serial收集器是最基础、历史最悠久的收集器，是一个单线程工作的收集器，在进行垃圾收集时必须暂停其他所有工作线程直到结束。其运行过程如图所示：</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220902172757928.png" alt="image-20220902172757928"></p>
<p>Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>​    ParNew收集器是Serial收集器的多线程并发版本。除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220902173000977.png" alt="image-20220902173000977"></p>
<p>ParNew是许多运行在服务端模式下的虚拟机的首要选择。随着时代的发展，ParNew并入了CMS，成为CMS专门处理新生代的组成部分。</p>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>​    Parallel Scavenge也是一款采用<strong>标记-复制</strong>的新生代收集器，也是java1.8默认的收集器(Parallel Scavenge + Parallel Old)。其目的是达到一个可控制的吞吐量，也就是高效率地利用CPU，适合在后台运算而不需要太多交互的任务。吞吐量是处理器用于运行用户代码的时间与处理器总消耗时间的比值，即</p>
<p>$$吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}$$。</p>
<p>​    Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。如果对于收集器运作不太了解，手工优化存在困难的话，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成也许是一个很不错的选择。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>​    Serial Old是Serial的老年代版本。在服务端模式下，它也可能有两种用途：一种是在<strong>JDK 5以及之前的版本中与Parallel Scavenge收集器搭配</strong>使用，另外一种就是作为<strong>CMS</strong>收集器<strong>发生失败</strong>时的后备预案，在<strong>并发收集发生Concurrent Mode Failure</strong>时使用。</p>
<h3 id="Parallel-Old收集"><a href="#Parallel-Old收集" class="headerlink" title="Parallel Old收集"></a>Parallel Old收集</h3><p>​    Parallel Old是Parallel Scavenge的老年代版本。支持多线程并发收集，基于标记-整理算法实现。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220902174803664.png" alt="image-20220902174803664"></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>​    CMS(Concurrent Mark Sweep)收集器<strong>是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong>CMS是 HotSpot 虚拟机<strong>第一款真正意义上的并发收集器</strong>，它第一次实现了让<strong>垃圾收集线程与用户线程（基本上）同时工作</strong>。CMS是基于<strong>标记-清除</strong>算法实现的，过程分为如下四个步骤：</p>
<ul>
<li>初始标记：初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。<strong>需要Stop The World</strong>。</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图，<strong>耗时较长但不会停止用户线程</strong>，可以与垃圾收集进程一起并发运行，由于有用户线程的进行，可能会导致引用发生变化，因此采用<strong>增量更新</strong>跟踪记录发生变化的地方。</li>
<li>重新标记：修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这一过程<strong>需要Stop The World</strong>，停顿的时间会比初始标记稍长一些，但是远比并发标记的时间短。</li>
<li>并发清除：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>
</ul>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220902180007805.png" alt="image-20220902180007805"></p>
<p>​    两个耗时比较长的并发标记和并发清除阶段都可以与用户线程一起运行，所以总体上CMS的内存回收是于用户线程一起运行的。</p>
<p>​    CMS有<strong>并发收集</strong>、<strong>低停顿</strong>的优点，但也存在下面三个缺点：</p>
<ul>
<li>对<strong>CPU资源敏感</strong>：虽然并发阶段不会停顿用户线程，但却会因为<strong>占用了一部分线程</strong>（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是$$\frac{（处理器核心数量+3）}{4}$$，当处理器核心数不够4个时，CMS对用户程序的影响就可能变大。</li>
<li><strong>无法处理浮动垃圾</strong>：这可能会出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。Java提供一个参数**-XX：CMSInitiatingOccu-pancyFraction**来使CMS在老年代使用了指定空间后被激活。参数如果设置过高容易使得预留内存不足导致并发失败触发Serial Old来进行老年代的收集而降低性能。</li>
<li>垃圾收集结束时可能会<strong>产生大量空间碎片</strong>：这是标记-清除算法的缺陷。CMS提供了两个参数(这两个参数在JDK 9开始废弃)<strong>-XX：+UseCMS-CompactAtFullCollection</strong>和**-XX：CMSFullGCsBefore-Compaction**。前者用于在CMS不得不Full GC时开启内存碎片的合并整理，但是会造成停顿时间长。后者是CMS在执行参数指定次不整理空间的Full GC后在进行下一次Full GC前进行碎片整理。</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>​    G1是一款主要面向<strong>服务端</strong>应用的垃圾收集器，它开创了收集器<strong>面向局部收集</strong>的设计思路和<strong>基于Region</strong>的内存布局形式。G1主要针对配备多颗处理器及大容量内存的机器。 以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。</p>
<p>​    G1不再像之前的收集器那样划分新生代和老年代，而是根据哪块内存的垃圾回收收益最大来进行回收，这就是G1的<strong>Mixed GC</strong>模式。G1通过<strong>基于Region的内存布局</strong>来实现这个目标，每个<strong>Region的大小都是相等</strong>的，每个Region都可以根据需要充当新生代或者老年代的角色。Region中有一类特殊的区域Humongous区域，专门用于存储大对象，只要大小超过Region容量一半的都会被G1认为是大对象，对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。G1之所以能建立可预测的停顿时间模型，是因为它将<strong>Region作为单次回收的最小单元</strong>，即每次收集到的内存空间都是<strong>Region大小的整数倍</strong>，这样可以有计划地<strong>避免在整个Java堆中进行全区域的垃圾收集</strong>。其做法是G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即<strong>回收所获得的空间大小以及回收所需时间的经验值</strong>，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也是”Garbage First”的名字由来。<strong>Region划分空间</strong>和<strong>按优先级回收区域</strong>的方式保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220902202918739.png" alt="image-20220902202918739"></p>
<p>​    G1也是使用记忆集来解决<strong>跨Region引用</strong>的问题，每个Region都维护有自己的记忆集，这些记忆集会<strong>记录下别的Region指向自己的指针</strong>，并<strong>标记这些指针分别在哪些卡页的范围之内</strong>。G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。</p>
<p>​    对于<strong>并发标记</strong>的问题，G1采用了<strong>原始快照</strong>(SATB)的方法来实现，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把<strong>Region中的一部分空间划分出来用于并发回收过程中的新对象分配</strong>，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。</p>
<p>​    G1的运行过程划分为以下四个阶段：</p>
<ul>
<li><p>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段<strong>需要停顿线程</strong>，但<strong>耗时很短</strong>，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段<strong>实际并没有额外的停顿</strong>。</p>
</li>
<li><p>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段<strong>耗时较长</strong>，但<strong>可与用户程序并发执行</strong>。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p>
</li>
<li><p>最终标记：<strong>对用户线程做另一个短暂的暂停</strong>，用于处理并发阶段结束后仍遗留下来的最后那少量的<strong>SATB记录</strong>。</p>
</li>
<li><p>筛选回收：负责<strong>更新Region的统计数据</strong>，<strong>对各个Region的回收价值和成本进行排序</strong>，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后<strong>把决定回收的那一部分Region的存活对象复制到空的Region中</strong>，再<strong>清理掉整个旧Region的全部空间</strong>。这里的操作<strong>涉及存活对象的移动</strong>，是<strong>必须暂停用户线程</strong>，由多条收集器线程并行完成的。</p>
<p>除了并发标记阶段都需要暂停用户线程。</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220902204357967.png" alt="image-20220902204357967"></p>
</li>
</ul>
<p>G1有这么些特点：</p>
<ul>
<li>空间整合：与 CMS 的“标记-清理”算法不同，G1 从<strong>整体</strong>来看是基于“<strong>标记-整理</strong>”算法实现的收集器；从<strong>局部</strong>上来看是基于“<strong>标记-复制</strong>”算法实现的。这意味着垃圾收集后仍能提供规整的可用内存。</li>
<li>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li>可预测停顿：G1能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。</li>
<li>分代收集：虽然G1采用了基于Region的内存布局，但还是保留了分代的概念。</li>
</ul>
<p>​    G1比起CMS，也是有存在缺点的。G1产生的<strong>内存占用和额外执行负载</strong>都比CMS要高，G1的<strong>卡表占用堆的空间可能达到20%甚至更多</strong>，而CMS只需维护一份卡表即可。还有G1为了实现原始快照算法，除了写后屏障还需要<strong>写前屏障</strong>来跟踪并发时的指针变化，虽然原始快照对比起增量更新能减少并发标记和重新标记的消耗，但<strong>跟踪引用变化</strong>带来的负担确实是会产生且要<strong>消耗更多的运算资源</strong>的，这就使得G1采用一种类似于<strong>消息队列</strong>的结构，把<strong>写前屏障和写后屏障要做的事情放到队列</strong>里然后再<strong>异步</strong>处理，而CMS只采用了写后屏障，而且可以同步操作。</p>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><p>​    最后来说下Java对内存的分配和回收。</p>
<p>​    对于大部分的对象，都是在Eden区中进行分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。如果GC期间发现Survivor空间的内存不足以将Eden的一些对象存入进去，则会通过<strong>分配担保机制</strong>将对象从新生代提前转移到老年代中。</p>
<p>​    对于大对象(需要<strong>大量连续内存空间</strong>的Java对象，最典型的大对象便是那种<strong>很长的字符串</strong>和<strong>元素数量庞大的数组</strong>)，则直接放入老年代中，这样做是为了<strong>避免在Eden区和两个Survivor区之间来回复制而产生大量的内存复制操作</strong>。在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着<strong>高额的内存复制开销</strong>。</p>
<p>​    对于在新生代中长期存活的对象，则要将对象放入老年代中，为做到这点，虚拟机给每个对象定义了一个<strong>对象年龄（Age）计数器</strong>，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。这个年龄的阈值是可以通过参数-XX：MaxTenuringThreshold来设置的，在<strong>CMS</strong>中，这个值为<strong>6</strong>。为了适应不同程序的内存状况，HotSpot并不永远要求对象年龄达到阈值才可以进入老年代，而是会采用动态年龄判断，如果在Survivor空间中<strong>相同年龄所有对象大小的总和大于Survivor空间的一半</strong>，<strong>年龄大于或等于该年龄的对象就可以直接进入老年代</strong>，无须等到-XX：MaxTenuringThreshold中要求的年龄。</p>
<p>​    前面我们提到了分配担保机制，也就是空间分配担保，在发生<strong>Minor GC之前</strong>，虚拟机必须先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值<strong>是否允许担保失败</strong>（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间<strong>是否大于历次晋升到老年代对象的平均大小</strong>，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次<strong>Full GC</strong>。虽然担保失败时会造成更长的停顿时间，但是通常情况下还是会允许担保来避免频繁的Full GC的。</p>
<hr>
<p>​    JVM的垃圾回收这部分内容大概总结的就是这些了(其实相当于摘抄了)，看书的时候也没怎么感觉到内容多，但没想到记起笔记来时会有这么的东西要记录，真的是超乎想象了，Mark了9000多个字和几个小时的笔记真的是好累(特别是眼睛)。限于篇幅和精力，ZGC和Shenandoah这两款低延迟垃圾收集器没有在这里进行笔记，这两款收集器在书里的描述还是挺多的，看不懂的话网上也有文章讲解这两款收集器。还是很推荐学习Java的人去阅读这本《深入理解Java虚拟机》的，纯看八股是死记硬背，尽管JavaGuide上面也已经总结好了，但我觉得自己结合书本再总结一遍那是更好的。</p>
<p>​    最后放个表情来表达我写完笔记后的状态：</p>
<p><img data-src="https://typora-oss-pic.oss-cn-guangzhou.aliyuncs.com/typoraImg/image-20220902221621598.png" alt="image-20220902221621598"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<ul>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践(第三版)》</li>
<li><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">JavaGuide：JVM垃圾回收详解</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
